<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AG!TOWER GAME</title>
  <meta property="og:title" content="AG!タワーゲーム" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://jun-ag.github.io/tower-game/" />
  <meta property="og:image" content="https://tower-game-production.up.railway.app/images/ogp.jpg" />
  <meta property="og:description" content="積み上げて遊ぶ物理パズルゲーム。部長を高く積み上げよう！" />
  <meta property="og:site_name" content="AG!タワーゲーム" />
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000000;
      font-family: Arial, sans-serif;
      touch-action: manipulation;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #gameContainer {
  width: 375px;
  height: 667px;
  background: url('./images/background.png') center/cover no-repeat;
  position: relative;
  overflow: hidden;
    }
    canvas {
      display: block;
      touch-action: none;
    }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      z-index: 100;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.75);
      color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 200;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    #gameClear {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(47, 0, 200, 0.9);
      color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 200;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    #restartBtn, #clearRestartBtn {
      background: #2317d0;
      color: white;
      border: none;
      padding: 15px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      margin-top: 15px;
    }
    #nextImage {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255,255,255,0.9);
      padding: 12px;
      border-radius: 12px;
      text-align: center;
      z-index: 100;
      width: 80px;
    }
    #previewImage {
      border: 2px solid #333;
      border-radius: 6px;
      background-color: #f0f0f0;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="ui">
      <div>SCORE: <span id="score">0</span></div>
      <div>部長: <span id="objectCount">0</span>人</div>
      <div style="color: #FFD700; font-weight: bold;">HIGH SCORE: <span id="highScore">0</span></div>
    </div>
    
    <div id="nextImage">
      <div style="color: #333; font-size: 14px; margin-bottom: 6px; font-weight: bold;">次:</div>
      <div id="previewImage" style="width: 50px; height: 50px; background: #ddd;"></div>
    </div>
    
    <div id="gameOver">
      <h2>GAME OVER</h2>
      <p>部長が舞台から落ちました</p>
      <p>FINAL SCORE: <span id="finalScore">0</span></p>
      <p id="newHighScore" style="color: #FFD700; font-weight: bold; display: none;">🎉 NEW HIGH SCORE! 🎉</p>
      <button id="restartBtn">PLAY AGAIN?</button>
    </div>
    
    <div id="gameClear">
      <h2>🎉 GAME CLEAR 🎉</h2>
      <p>部長が高みに到達しました</p>
      <p>FINAL SCORE: <span id="clearScore">0</span></p>
      <p id="newHighScoreClear" style="color: #FFD700; font-weight: bold; display: none;">🎉 NEW HIGH SCORE! 🎉</p>
      <button id="clearRestartBtn">PLAY AGAIN?</button>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
  <script>
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const World = Matter.World;
    const Bodies = Matter.Bodies;
    const Runner = Matter.Runner;
    
    let engine, world, render, runner;
    let score = 0;
    let objectCount = 0;
    let gameRunning = true;
    let objects = [];
    let platform;
    let currentImageIndex = 0;
    let nextImageIndex = 0;
    let lastDropTime = 0;
    let objectDropTimes = [];
    let highScore = 0;
    
    // 出現頻度調整用の抽選プール
    let imageDrawPool = [];
    
    const GAME_WIDTH = 375;
    const GAME_HEIGHT = 667;
    
    const imageData = [

      // A.png の当たり判定を変更
      { 
        name: 'A', 
        path: './images/A.png', 
        width: 80, 
        height: 40, 
        type: 'fromVertices', // ★ タイプを「頂点から作る」に指定
        scale: 0.5,
        vertices: [ // ★ ここに9個の頂点座標が設定されています
          { x: -37, y: -19 }, { x: -15, y: -16 }, { x: -2, y: -4 },
          { x: 32, y: -18 }, { x: 39, y: -11 }, { x: 12, y: 19 },
          { x: -29, y: 19 }, { x: -22, y: -7 }, { x: -39, y: -14 },
   
        ]
      },


      { name: 'B', path: './images/B.png', width: 60, height: 80, type: 'rectangle', scale: 0.5 },
    

// C.png の当たり判定を変更
      { 
        name: 'C', 
        path: './images/C.png', 
        width: 65, 
        height: 80, 
        type: 'fromVertices', // ★ タイプを「頂点から作る」に指定
        scale: 0.5,
        vertices: [ // ★ ここに6個の頂点座標が設定されています
          { x: 0, y: -40 }, { x: 31, y: 11 }, { x: 28, y: 22 },
          { x: 1, y: 39 }, { x: -30, y: 21 }, { x: -30, y: 12 },
        ]
      },
      


      { name: 'D', path: './images/D.png', width: 75, height: 80, type: 'rectangle', scale: 0.5 },
      { name: 'E', path: './images/E.png', width: 30, height: 80, type: 'rectangle', scale: 0.5 },
      { name: 'F', path: './images/F.png', width: 80, height: 50, type: 'rectangle', scale: 0.5 },
      // G.png の当たり判定を変更
      { 
        name: 'G', 
        path: './images/G.png', 
        width: 70, 
        height: 80, 
        type: 'fromVertices', 
        scale: 0.5,
        vertices: [
          { x: -34, y: -17 }, { x: 1, y: -39 }, { x: 12, y: -36 },
          { x: 3, y: -22 }, { x: 35, y: 40 }, { x: 25, y: 40 },
          { x: 19, y: 23 }, { x: -13, y: 26 }, { x: -17, y: 40 },
          { x: -29, y: 40 }, { x: -19, y: 13 }
        ]
      },
      { 
        name: 'H', 
        path: './images/H.png', 
        width: 80, 
        height: 55, 
        type: 'fromVertices',
        scale: 0.5,
        vertices: [
          { x: -29, y: -27 }, { x: -20, y: -27 }, { x: -3, y: -22 },
          { x: 40, y: 20 }, { x: 40, y: 27 }, { x: -39, y: 25 },
          { x: -36, y: -12 }
        ]
      },
      { name: 'I', path: './images/I.png', width: 40, height: 40, type: 'circle', scale: 0.5 },
      { name: 'J', path: './images/J.png', width: 80, height: 140, type: 'rectangle', scale: 0.5 },
      { name: 'K', path: './images/K.png', width: 43, height: 90, type: 'rectangle', scale: 0.5 },
      { name: 'L', path: './images/L.png', width: 28, height: 115, type: 'rectangle', scale: 0.5 },
      { name: 'M', path: './images/M.png', width: 30, height: 50, type: 'rectangle', scale: 0.5 }
    ];
    
    function initGame() {
      engine = Engine.create();
      world = engine.world;
      engine.world.gravity.y = 0.6;
      
      render = Render.create({
        element: document.getElementById('gameContainer'),
        engine: engine,
        options: {
          width: GAME_WIDTH,
          height: GAME_HEIGHT,
          wireframes: false,
          background: 'transparent',
          pixelRatio: 2
        }
      });
      
      const platformWidth = 300;
      const platformY = 550;
      
      platform = Bodies.rectangle(
        GAME_WIDTH / 2,
        platformY,
        platformWidth,
        20,
        { 
          isStatic: true, 
          render: { 
            fillStyle: '#8B4513',
            strokeStyle: '#654321',
            lineWidth: 2
          }
        }
      );
      World.add(world, platform);
      
      score = 0;
      objectCount = 0;
      gameRunning = true;
      objects = [];
      objectDropTimes = [];
      lastDropTime = 0;
      
      imageDrawPool = [];
      for (let i = 0; i < imageData.length; i++) {
        if (imageData[i].name === 'J') {
          imageDrawPool.push(i);
        } else {
          for (let j = 0; j < 5; j++) {
            imageDrawPool.push(i);
          }
        }
      }
      nextImageIndex = imageDrawPool[Math.floor(Math.random() * imageDrawPool.length)];
      
      updateUI();
      updatePreview();
      
      console.log('ゲーム初期化完了');
    }
    
    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('objectCount').textContent = objectCount;
      document.getElementById('highScore').textContent = highScore;
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('gameClear').style.display = 'none';
    }
    
    function updatePreview() {
      const preview = document.getElementById('previewImage');
      const nextImage = imageData[nextImageIndex];
      
      const maxSize = 50;
      let previewWidth, previewHeight;
      
      if (nextImage.width >= nextImage.height) {
        previewWidth = maxSize;
        previewHeight = (nextImage.height / nextImage.width) * maxSize;
      } else {
        previewHeight = maxSize;
        previewWidth = (nextImage.width / nextImage.height) * maxSize;
      }
      
      preview.style.width = previewWidth + 'px';
      preview.style.height = previewHeight + 'px';
      preview.style.backgroundImage = `url(${nextImage.path})`;
      preview.style.backgroundSize = 'contain';
      preview.style.backgroundRepeat = 'no-repeat';
      preview.style.backgroundPosition = 'center';
    }
    
    function dropObject(x) {
      if (!gameRunning) return;
      
      const currentTime = Date.now();
      if (currentTime - lastDropTime < 300) return;
      lastDropTime = currentTime;
      
      currentImageIndex = nextImageIndex;
      const imageInfo = imageData[currentImageIndex];
      
      let body;
      
      const commonOptions = {
        restitution: 0.2,
        friction: 0.9,
        density: 0.0008,
        render: {
          sprite: {
            texture: imageInfo.path,
            xScale: imageInfo.scale,
            yScale: imageInfo.scale
          }
        }
      };
      
      if (imageInfo.type === 'circle') {
        const radius = Math.max(imageInfo.width, imageInfo.height) / 2;
        body = Bodies.circle(x, 50, radius, {
          ...commonOptions,
          restitution: 0.4,
          friction: 0.7,
        });
      } else if (imageInfo.type === 'fromVertices') {
        body = Bodies.fromVertices(x, 50, [imageInfo.vertices], commonOptions);
      } else {
        body = Bodies.rectangle(x, 50, imageInfo.width, imageInfo.height, commonOptions);
      }
      
      World.add(world, body);
      objects.push(body);
      objectDropTimes.push(currentTime);
      
      const sizeBonus = Math.floor((imageInfo.width * imageInfo.height) / 100);
      score += 10 + sizeBonus;
      if (imageInfo.name === 'J') {
        objectCount += 4;
      } else {
        objectCount++;
      }
      
      nextImageIndex = imageDrawPool[Math.floor(Math.random() * imageDrawPool.length)];
      
      updateUI();
      updatePreview();
    }
    
    function checkGameOver() {
      if (!gameRunning) return;
      
      const currentTime = Date.now();
      const platformBottom = platform.position.y + 10;
      const gameOverLine = platformBottom + 150;
      
      for (let obj of objects) {
        if (obj.position.y > gameOverLine) {
          gameOver();
          return;
        }
      }
      
      const clearLine = 180;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        const dropTime = objectDropTimes[i];
        
        if (currentTime - dropTime > 3000 && 
            obj.position.y < clearLine &&
            Math.abs(obj.velocity.y) < 1.0) {
          gameClear();
          return;
        }
      }
    }
    
    function gameOver() {
      gameRunning = false;
      
      const isNewHighScore = score > highScore;
      if (isNewHighScore) {
        highScore = score;
        document.getElementById('newHighScore').style.display = 'block';
      } else {
        document.getElementById('newHighScore').style.display = 'none';
      }
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';
    }
    
    function gameClear() {
      gameRunning = false;
      
      const isNewHighScore = score > highScore;
      if (isNewHighScore) {
        highScore = score;
        document.getElementById('newHighScoreClear').style.display = 'block';
      } else {
        document.getElementById('newHighScoreClear').style.display = 'none';
      }
      
      document.getElementById('clearScore').textContent = score;
      document.getElementById('gameClear').style.display = 'block';
    }
    
    function restart() {
      if (render) {
        Render.stop(render);
        if (render.canvas && render.canvas.parentNode) {
          render.canvas.parentNode.removeChild(render.canvas);
        }
      }
      if (runner) {
        Runner.stop(runner);
      }
      Engine.clear(engine);
      
      initGame();
      runner = Runner.create();
      Runner.run(runner, engine);
      Render.run(render);
    }
    
    let eventListenersAdded = false;
    
    function addEventListeners() {
      if (eventListenersAdded) return;
      eventListenersAdded = true;
      
      document.getElementById('gameContainer').addEventListener('click', function(event) {
        if (event.target.closest('#gameOver') || event.target.closest('#restartBtn') || 
            event.target.closest('#nextImage') || event.target.closest('#gameClear') ||
            event.target.closest('#clearRestartBtn')) {
          return;
        }
        
        const rect = event.currentTarget.getBoundingClientRect();
        const x = event.clientX - rect.left;
        dropObject(x);
      });
      
      document.getElementById('gameContainer').addEventListener('touchstart', function(event) {
        if (event.target.closest('#gameOver') || event.target.closest('#restartBtn') || 
            event.target.closest('#nextImage') || event.target.closest('#gameClear') ||
            event.target.closest('#clearRestartBtn')) {
          return;
        }
        event.preventDefault();
        
        const rect = event.currentTarget.getBoundingClientRect();
        const touch = event.touches[0];
        const x = touch.clientX - rect.left;
        dropObject(x);
      });
      
      document.getElementById('restartBtn').addEventListener('click', restart);
      document.getElementById('clearRestartBtn').addEventListener('click', restart);
    }
    
    initGame();
    runner = Runner.create();
    Runner.run(runner, engine);
    Render.run(render);
    addEventListeners();
    
    setInterval(checkGameOver, 200);
  </script>
</body>
</html>